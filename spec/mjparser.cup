package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}
terminal PROG, BREAK, CLASS, IF, ELSE, CONST, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOR, STATIC, NAMESPACE ;
terminal PLUS_PLUS, PLUS, MINUS_MINUS, MINUS, STAR, SLASH, PERCENT ;
terminal EQUAL_EQUAL, NOT_EQUAL, GREAT_EQUAL, LESS_EQUAL, GREAT, LESS, AND, OR ;
terminal WILL_NAME_LATER, EQUAL, SEMI, COLON, COMMA, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE ;

terminal Integer NUMBER ;
terminal String IDENT ;
terminal Boolean BOOL;
terminal Character CHAR;


nonterminal ProgramDeclList, NamespaceList, Namespace, NamespaceName;
nonterminal MethodDeclList, ConstDecl, ConstDeclMulti, VarDecl, VarDeclMulti, ClassDecl ;
nonterminal ExtendsType;
nonterminal StaticVarDeclList, StaticVarDecl, StaticInitializerList, StaticInitializer, StaticMethodDecl ;
nonterminal StatementList, Statement, FormParamList, FormPars, FormParsEpsilon;
nonterminal DesignatorStatementListEpsilonFirst, DesignatorStatementListEpsilon, DesignatorStatementList, DesignatorStatement, DesignatorEpsilon, DesignatorArray;
nonterminal ElseStatementEpsilon, CondFactEpsilon, ActParsEpsilon, ActPars ;
nonterminal RelOp, RelOpEqual;	
nonterminal OpenScope, CloseScope;
nonterminal VarDeclMultiError;

nonterminal  Program  ; 
nonterminal  VarDeclList; 

nonterminal rs.ac.bg.etf.pp1.Sender AddOp, MulOp, NumCharBool;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, MethodDecl, MethodTypeName, Designator ;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Factor, Term, Expr, DesignatorOp;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Condition, CondTerm, CondFact;

nonterminal IfConditionStart, IfConditionEnd;
nonterminal ORoperator, ANDoperator;
nonterminal ThenStart, ElseStart, ThenEnd, ElseEnd;
nonterminal CondFactStart;
nonterminal rs.etf.pp1.symboltable.concepts.Obj DesignatorLeft, DesignatorRight;

precedence left ELSE;

Program ::=  (ProgramClass) PROG ProgName:p NamespaceList ProgramDeclList LBRACE MethodDeclList RBRACE 
;


ProgName ::=  (ProgNameClass) IDENT:progNameAttr
;

NamespaceList ::= NamespaceList Namespace
					|
					 /* epsilon */
					;
					
Namespace ::=  (NamespaceClass) NAMESPACE NamespaceName LBRACE ProgramDeclList LBRACE MethodDeclList RBRACE RBRACE
;

NamespaceName ::= (NamespaceNameClass) IDENT:nmspNameAttr
;

ProgramDeclList ::= (ProgramDeclListClass1) ProgramDeclList ConstDecl
					|
					(ProgramDeclListClass2) ProgramDeclList VarDecl
					|
					(ProgramDeclListClass3) ProgramDeclList ClassDecl
					|
					 /* epsilon */
					;
/*
VarDeclList ::= (VarDeclarations) VarDeclList VarDecl  
				|
				(NoVarDecl)/* epsilon 
				;*/
				
ConstDecl ::=  (ConstDeclClass) CONST Type IDENT:constNameAttr EQUAL NumCharBool ConstDeclMulti SEMI
;

ConstDeclMulti ::=  (ConstDeclMultiClass) ConstDeclMulti COMMA IDENT:constNameAttr EQUAL NumCharBool 
				|
				/* epsilon */
				;					

NumCharBool ::=  (IntClass2) NUMBER:numberAttr
				|
				(CharClass2) CHAR:charAttr
				|
				(BoolClass2) BOOL:boolAttr
;


VarDeclList ::=  VarDeclList VarDecl  
				|
				/* epsilon */ 
				;

VarDecl ::= (VarDeclClass) Type:varType IDENT:varNameAttr  VarDeclMulti SEMI 
			|
			(VarArrayDeclClass) Type:varType IDENT:varNameAttr LBRACKET RBRACKET VarDeclMulti SEMI 
			|
			error SEMI
			{: parser.report_error("Izvrsen oporavak od greske!", null); :}
			|
			error COMMA VarDeclMultiError SEMI
			{: parser.report_error("Izvrsen oporavak od greske!", null); :}
			;

VarDeclMulti ::= (VarDeclMultiClass) VarDeclMulti COMMA IDENT:varNameAttr 
				|
				(VarArrayDeclMultiClass) VarDeclMulti COMMA IDENT:varNameAttr LBRACKET RBRACKET 
				|
				/* epsilon */
				;
				
VarDeclMultiError ::= (VarDeclMultiErrorClass1) IDENT:varNameAttr  COMMA VarDeclMultiError
					|
					(VarDeclMultiErrorClass2) IDENT:varNameAttr  
					;
/***********************************************************************************************************************************************************/
ClassDecl ::= CLASS IDENT ExtendsType LBRACE StaticVarDeclList StaticInitializerList VarDeclList StaticMethodDecl RBRACE
;

ExtendsType ::= EXTENDS Type
			|
			/* epsilon */
			;
StaticVarDeclList ::= 	StaticVarDeclList StaticVarDecl
						|	
						/* epsilon */
						;
							
StaticVarDecl ::= STATIC VarDecl
;

StaticInitializerList ::= StaticInitializer StaticInitializerList
							|
							/* epsilon */
							;

StaticInitializer ::= STATIC LBRACE StatementList RBRACE
;

				
StaticMethodDecl ::= LBRACE MethodDeclList RBRACE
					|
					/* epsilon */
					;
/***********************************************************************************************************************************************************/
					
MethodDeclList ::=  MethodDeclList MethodDecl
					|
					/* epsilon */
					;

MethodDecl ::= (MethodDeclClass) MethodTypeName LPAREN FormParsEpsilon RPAREN VarDeclList LBRACE StatementList RBRACE 
			   ;
			   
MethodTypeName ::= 	(MethodTypeNameClass) Type:retType IDENT:methName
					|
				 	(MethodVoidNameClass) VOID IDENT:methName
					;
/***********************************************************************************************************************************************************/

FormParsEpsilon ::=  FormParamList 
			| 
			/* epsilon */
			|
			error
			{: parser.report_error("Izvrsen oporavak od greske!", null); :}
			;

FormParamList ::=	FormParamList COMMA FormPars
					|
					FormPars
					|
					error {: parser.report_error("Izvrsen oporavak od greske!", null); :} COMMA FormPars
					;
					
FormPars ::=  	(FormParamArrayClass) Type IDENT:paramNameAttr LBRACKET RBRACKET
				|
		 		(FormParamClass) Type IDENT:paramNameAttr
				;
/***********************************************************************************************************************************************************/

Type ::= (TypeClass) IDENT:typeName
		|
		 IDENT COLON COLON IDENT 
		;
/***********************************************************************************************************************************************************/

StatementList ::= (StatementListClass) StatementList Statement 
					|
				  (NoStmt) /* epsilon */
				  ;

Statement ::= DesignatorStatement SEMI
			|
			(StatementIfClass) IF LPAREN IfConditionStart Condition IfConditionEnd RPAREN ThenStart Statement ThenEnd
			|
			(StatementIfElseClass) IF LPAREN IfConditionStart Condition IfConditionEnd RPAREN ThenStart Statement ELSE ElseStart Statement ElseEnd
			|
			(StatementBreakClass) BREAK SEMI
			|
			(StatementContinueClass) CONTINUE SEMI
			|
			(ReturnExprClass) RETURN Expr SEMI
			|
			(ReturnNoExprClass) RETURN SEMI
			|
			(StatementReadClass) READ LPAREN Designator RPAREN SEMI
			|
			(PrintStmtNumberClass) PRINT LPAREN Expr COMMA NUMBER:numberAttr RPAREN SEMI
			|
			(PrintStmtClass) PRINT LPAREN Expr RPAREN SEMI
			|
			(StatementForLoopClass) FOR LPAREN DesignatorStatementListEpsilonFirst SEMI CondFactStart CondFactEpsilon SEMI DesignatorStatementListEpsilon RPAREN Statement
			|
			OpenScope StatementList CloseScope
			|
			Designator EQUAL error {: parser.report_error("Izvrsen oporavak od greske!", null); :} SEMI
			|
			error {: parser.report_error("Izvrsen oporavak od greske!", null); :} EQUAL Designator  SEMI
			;
			
IfConditionStart ::= (IfConditionStartClass) /* epsilon */
;
			
IfConditionEnd ::= (IfConditionEndClass) /* epsilon */
;

ThenStart ::= (ThenStartClass) /* epsilon */
;

ElseStart ::= (ElseStartClass) /* epsilon */
;

ThenEnd ::= (ThenEndClass) /* epsilon */
;

ElseEnd ::= (ElseEndClass) /* epsilon */
;

CondFactStart ::= (CondFactStartClass) /* epsilon */
;

OpenScope ::= (OpenScopeClass) LBRACE
;

CloseScope ::= (CloseScopeClass) RBRACE
;



/*
Statement ::= (MatchedStmt) Matched | (UnmachedStmt) Unmatched ;

Unmatched ::= (UnmatchedIf) IF Expr Statement | (UnmatchedIfElse) IF Expr Matched ELSE Unmatched;
	
				  
Matched ::= (Assignment) Designator:dest EQUAL Expr:e SEMI 
			  |
			  (ErrAssignment) Designator EQUAL error SEMI
			  {: parser.log.debug("Uspesan oporavak od greske pri dodeli vrednosti."); :}
			  |
			  (PrintStmt) PRINT LPAREN Expr RPAREN SEMI 
			  |
			  (ReturnExpr) RETURN Expr:t SEMI
			  |
			  (ReturnNoExpr) RETURN SEMI
			  | 
			  (MatchedIf) IF Expr Matched ELSE Matched
			  |
			  (ProcCall) Designator:func LPAREN ActualPars RPAREN SEMI
			  ;
*/		
DesignatorStatementListEpsilon ::= (ForLoopStatementClass) DesignatorStatementList
									|
									(ForLoopStatementEpsilonClass) /* epsilon */
									;

DesignatorStatementListEpsilonFirst ::=  (ForLoopStartClass) DesignatorStatementList
										|
										 (ForLoopStartClass2)/* epsilon */
										;
						
DesignatorStatementList ::= DesignatorStatementList COMMA DesignatorStatement  
							|
							DesignatorStatement
							;
DesignatorStatement ::= (DesignatorAssignmentClass) Designator EQUAL Expr
						|
 						(DesignatorFunctionClass) Designator LPAREN ActParsEpsilon RPAREN
						|
						(DesignatorIncClass) Designator PLUS_PLUS
						|
 						(DesignatorDecClass) Designator MINUS_MINUS
						|
						(DesignatorArrayAssignmentClass) LBRACKET DesignatorArray STAR DesignatorLeft RBRACKET EQUAL DesignatorRight
						;
						
DesignatorLeft ::= (DesignatorLeftClass) Designator
;			
			
DesignatorRight ::= (DesignatorRightClass) Designator
;
		
DesignatorArray ::= (DesignatorArrayDesignatorArrayClass) DesignatorArray Designator COMMA
					|
					(DesignatorArrayDesignatorClass) DesignatorArray  COMMA
					|
					/* epsilon */
					;
				
ActParsEpsilon ::= ActPars
				|
				/* epsilon */
				;
				
ActPars ::= (ActParamMultiClass) ActPars COMMA Expr
			|
			(ActParamClass) Expr
			;
Condition ::= 	(ConditionOrClass) Condition ORoperator CondTerm
				|
				(ConditionNoOrClass) CondTerm 
				|
				error
				{: parser.report_error("Izvrsen oporavak od greske!", null); :}
				;

ORoperator ::= (ORoperatorClass) OR;

CondTerm ::= (CondTermAndClass) CondTerm ANDoperator CondFact
			 |
			 (CondTermNoAndClass) CondFact
			 ;
			 
ANDoperator ::= (ANDoperatorClass) AND;

CondFactEpsilon ::= (ForLoopCondFactClass) CondFact
					|
					(ForLoopNoCondFactClass) /* epsilon */
					;
					
CondFact ::= (CondFactNoRelOpClass) Expr 
			|
			(CondFactRelOpClass) Expr RelOp Expr
			|
			(CondFactRelOpEqualClass) Expr RelOpEqual Expr
			;
			
Expr ::= (AddExprClass) Expr:te AddOp Term:t
		 |
		 (ExprTermClass) Term:t
		 |
		 (ExprMinusTermClass) MINUS Term
		 ;

Term ::= (TermMulopFactorClass) Term MulOp Factor
		 |
		 (TermFactorClass) Factor:t 
		 ;
Factor ::= 	(VarClass) Designator 
			|
			(FuncCallClass) Designator LPAREN ActParsEpsilon RPAREN
			|
			(IntClass) NUMBER
			|
			(CharClass) CHAR
			|
			(BoolClass) BOOL
			|
			(NewArrayClass) NEW Type LBRACKET Expr RBRACKET
			|
			NEW Type LPAREN ActParsEpsilon RPAREN
			|
			(ParenExprClass) LPAREN Expr RPAREN
			;



Designator ::=  (DesignatorFieldClass) Designator DOT IDENT
				|
				(DesignatorArrayClass) Designator LBRACKET Expr RBRACKET
				|
				(DesignatorIdentClass) IDENT:nameAttr
				|
				(DesignatorNmspIdentClass) IDENT:nmspAttr COLON COLON IDENT:nameAttr
				;
/*
ActualPars ::= (Actuals) ActualParamList 
				| 
			   (NoActuals)  epsilon  
			   ;
			   
ActualParamList ::= (ActualParams) ActualParamList COMMA Expr
					|
					(ActualParam) Expr
					;*/
RelOpEqual ::= 	(EqualEqualClass) EQUAL_EQUAL
				|
				(NotEqualClass) NOT_EQUAL
				;
			
RelOp ::= 	(GreaterThanClass) GREAT
			|
			(GreaterEqualClass) GREAT_EQUAL
			|
			(LesserThanClass) LESS
			|
			(LesserEqualClass) LESS_EQUAL
			;
			
AddOp ::= 	(AddOpClass) PLUS
			|
			(SubOpClass) MINUS
			;

MulOp ::=	(MulOpClass) STAR
			|
			(DivOpClass) SLASH
			|
			(ModOpClass) PERCENT
			;
				

					